Index: js/jquery.csv.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* eslint no-prototype-builtins: 0 */\r\n/**\r\n * jQuery-csv (jQuery Plugin)\r\n *\r\n * This document is licensed as free software under the terms of the\r\n * MIT License: http://www.opensource.org/licenses/mit-license.php\r\n *\r\n * Acknowledgements:\r\n * The original design and influence to implement this library as a jquery\r\n * plugin is influenced by jquery-json (http://code.google.com/p/jquery-json/).\r\n * If you're looking to use native JSON.Stringify but want additional backwards\r\n * compatibility for browsers that don't support it, I highly recommend you\r\n * check it out.\r\n *\r\n * A special thanks goes out to rwk@acm.org for providing a lot of valuable\r\n * feedback to the project including the core for the new FSM\r\n * (Finite State Machine) parsers. If you're looking for a stable TSV parser\r\n * be sure to take a look at jquery-tsv (http://code.google.com/p/jquery-tsv/).\r\n\r\n * For legal purposes I'll include the \"NO WARRANTY EXPRESSED OR IMPLIED.\r\n * USE AT YOUR OWN RISK.\". Which, in 'layman's terms' means, by using this\r\n * library you are accepting responsibility if it breaks your code.\r\n *\r\n * Legal jargon aside, I will do my best to provide a useful and stable core\r\n * that can effectively be built on.\r\n *\r\n * Copyrighted 2012 by Evan Plaice.\r\n */\r\n\r\nRegExp.escape = function (s) {\r\n  return s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\r\n};\r\n\r\n(function () {\r\n  'use strict';\r\n\r\n  var $;\r\n\r\n  // to keep backwards compatibility\r\n  if (typeof jQuery !== 'undefined' && jQuery) {\r\n    $ = jQuery;\r\n  } else {\r\n    $ = {};\r\n  }\r\n\r\n  /**\r\n   * jQuery.csv.defaults\r\n   * Encapsulates the method paramater defaults for the CSV plugin module.\r\n   */\r\n\r\n  $.csv = {\r\n    defaults: {\r\n      separator: ',',\r\n      delimiter: '\"',\r\n      headers: true\r\n    },\r\n\r\n    hooks: {\r\n      castToScalar: function (value, state) {\r\n        var hasDot = /\\./;\r\n        if (isNaN(value)) {\r\n          return value;\r\n        } else {\r\n          if (hasDot.test(value)) {\r\n            return parseFloat(value);\r\n          } else {\r\n            var integer = parseInt(value);\r\n            if (isNaN(integer)) {\r\n              return null;\r\n            } else {\r\n              return integer;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    parsers: {\r\n      parse: function (csv, options) {\r\n        // cache settings\r\n        var separator = options.separator;\r\n        var delimiter = options.delimiter;\r\n\r\n        // set initial state if it's missing\r\n        if (!options.state.rowNum) {\r\n          options.state.rowNum = 1;\r\n        }\r\n        if (!options.state.colNum) {\r\n          options.state.colNum = 1;\r\n        }\r\n\r\n        // clear initial state\r\n        var data = [];\r\n        var entry = [];\r\n        var state = 0;\r\n        var value = '';\r\n        var exit = false;\r\n\r\n        function endOfEntry () {\r\n          // reset the state\r\n          state = 0;\r\n          value = '';\r\n\r\n          // if 'start' hasn't been met, don't output\r\n          if (options.start && options.state.rowNum < options.start) {\r\n            // update global state\r\n            entry = [];\r\n            options.state.rowNum++;\r\n            options.state.colNum = 1;\r\n            return;\r\n          }\r\n\r\n          if (options.onParseEntry === undefined) {\r\n            // onParseEntry hook not set\r\n            data.push(entry);\r\n          } else {\r\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\r\n            // false skips the row, configurable through a hook\r\n            if (hookVal !== false) {\r\n              data.push(hookVal);\r\n            }\r\n          }\r\n          // console.log('entry:' + entry);\r\n\r\n          // cleanup\r\n          entry = [];\r\n\r\n          // if 'end' is met, stop parsing\r\n          if (options.end && options.state.rowNum >= options.end) {\r\n            exit = true;\r\n          }\r\n\r\n          // update global state\r\n          options.state.rowNum++;\r\n          options.state.colNum = 1;\r\n        }\r\n\r\n        function endOfValue () {\r\n          if (options.onParseValue === undefined) {\r\n            // onParseValue hook not set\r\n            entry.push(value);\r\n          } else if (options.headers && options.state.rowNum === 1) {\r\n            // don't onParseValue object headers\r\n            entry.push(value);\r\n          } else {\r\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\r\n            // false skips the row, configurable through a hook\r\n            if (hook !== false) {\r\n              entry.push(hook);\r\n            }\r\n          }\r\n          // console.log('value:' + value);\r\n          // reset the state\r\n          value = '';\r\n          state = 0;\r\n          // update global state\r\n          options.state.colNum++;\r\n        }\r\n\r\n        // escape regex-specific control chars\r\n        var escSeparator = RegExp.escape(separator);\r\n        var escDelimiter = RegExp.escape(delimiter);\r\n\r\n        // compile the regEx str using the custom delimiter/separator\r\n        var match = /(D|S|\\r\\n|\\n|\\r|[^DS\\r\\n]+)/;\r\n        var matchSrc = match.source;\r\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\r\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\r\n        match = new RegExp(matchSrc, 'gm');\r\n\r\n        // put on your fancy pants...\r\n        // process control chars individually, use look-ahead on non-control chars\r\n        csv.replace(match, function (m0) {\r\n          if (exit) {\r\n            return;\r\n          }\r\n          switch (state) {\r\n            // the start of a value\r\n            case 0:\r\n              // null last value\r\n              if (m0 === separator) {\r\n                value += '';\r\n                endOfValue();\r\n                break;\r\n              }\r\n              // opening delimiter\r\n              if (m0 === delimiter) {\r\n                state = 1;\r\n                break;\r\n              }\r\n              // null last value\r\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\r\n                endOfValue();\r\n                endOfEntry();\r\n                break;\r\n              }\r\n              // un-delimited value\r\n              value += m0;\r\n              state = 3;\r\n              break;\r\n\r\n            // delimited input\r\n            case 1:\r\n              // second delimiter? check further\r\n              if (m0 === delimiter) {\r\n                state = 2;\r\n                break;\r\n              }\r\n              // delimited data\r\n              value += m0;\r\n              state = 1;\r\n              break;\r\n\r\n            // delimiter found in delimited input\r\n            case 2:\r\n              // escaped delimiter?\r\n              if (m0 === delimiter) {\r\n                value += m0;\r\n                state = 1;\r\n                break;\r\n              }\r\n              // null value\r\n              if (m0 === separator) {\r\n                endOfValue();\r\n                break;\r\n              }\r\n              // end of entry\r\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\r\n                endOfValue();\r\n                endOfEntry();\r\n                break;\r\n              }\r\n              // broken paser?\r\n              throw Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\r\n\r\n            // un-delimited input\r\n            case 3:\r\n              // null last value\r\n              if (m0 === separator) {\r\n                endOfValue();\r\n                break;\r\n              }\r\n              // end of entry\r\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\r\n                endOfValue();\r\n                endOfEntry();\r\n                break;\r\n              }\r\n              if (m0 === delimiter) {\r\n              // non-compliant data\r\n                throw Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\r\n              }\r\n              // broken parser?\r\n              throw Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\r\n            default:\r\n              // shenanigans\r\n              throw Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\r\n          }\r\n          // console.log('val:' + m0 + ' state:' + state);\r\n        });\r\n\r\n        // submit the last entry\r\n        // ignore null last line\r\n        if (entry.length !== 0) {\r\n          endOfValue();\r\n          endOfEntry();\r\n        }\r\n\r\n        return data;\r\n      },\r\n\r\n      // a csv-specific line splitter\r\n      splitLines: function (csv, options) {\r\n        if (!csv) {\r\n          return undefined;\r\n        }\r\n\r\n        options = options || {};\r\n\r\n        // cache settings\r\n        var separator = options.separator || $.csv.defaults.separator;\r\n        var delimiter = options.delimiter || $.csv.defaults.delimiter;\r\n\r\n        // set initial state if it's missing\r\n        options.state = options.state || {};\r\n        if (!options.state.rowNum) {\r\n          options.state.rowNum = 1;\r\n        }\r\n\r\n        // clear initial state\r\n        var entries = [];\r\n        var state = 0;\r\n        var entry = '';\r\n        var exit = false;\r\n\r\n        function endOfLine () {\r\n          // reset the state\r\n          state = 0;\r\n\r\n          // if 'start' hasn't been met, don't output\r\n          if (options.start && options.state.rowNum < options.start) {\r\n            // update global state\r\n            entry = '';\r\n            options.state.rowNum++;\r\n            return;\r\n          }\r\n\r\n          if (options.onParseEntry === undefined) {\r\n            // onParseEntry hook not set\r\n            entries.push(entry);\r\n          } else {\r\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\r\n            // false skips the row, configurable through a hook\r\n            if (hookVal !== false) {\r\n              entries.push(hookVal);\r\n            }\r\n          }\r\n\r\n          // cleanup\r\n          entry = '';\r\n\r\n          // if 'end' is met, stop parsing\r\n          if (options.end && options.state.rowNum >= options.end) {\r\n            exit = true;\r\n          }\r\n\r\n          // update global state\r\n          options.state.rowNum++;\r\n        }\r\n\r\n        // escape regex-specific control chars\r\n        var escSeparator = RegExp.escape(separator);\r\n        var escDelimiter = RegExp.escape(delimiter);\r\n\r\n        // compile the regEx str using the custom delimiter/separator\r\n        var match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/;\r\n        var matchSrc = match.source;\r\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\r\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\r\n        match = new RegExp(matchSrc, 'gm');\r\n\r\n        // put on your fancy pants...\r\n        // process control chars individually, use look-ahead on non-control chars\r\n        csv.replace(match, function (m0) {\r\n          if (exit) {\r\n            return;\r\n          }\r\n          switch (state) {\r\n            // the start of a value/entry\r\n            case 0:\r\n              // null value\r\n              if (m0 === separator) {\r\n                entry += m0;\r\n                state = 0;\r\n                break;\r\n              }\r\n              // opening delimiter\r\n              if (m0 === delimiter) {\r\n                entry += m0;\r\n                state = 1;\r\n                break;\r\n              }\r\n              // end of line\r\n              if (m0 === '\\n') {\r\n                endOfLine();\r\n                break;\r\n              }\r\n              // phantom carriage return\r\n              if (/^\\r$/.test(m0)) {\r\n                break;\r\n              }\r\n              // un-delimit value\r\n              entry += m0;\r\n              state = 3;\r\n              break;\r\n\r\n            // delimited input\r\n            case 1:\r\n              // second delimiter? check further\r\n              if (m0 === delimiter) {\r\n                entry += m0;\r\n                state = 2;\r\n                break;\r\n              }\r\n              // delimited data\r\n              entry += m0;\r\n              state = 1;\r\n              break;\r\n\r\n            // delimiter found in delimited input\r\n            case 2:\r\n              // escaped delimiter?\r\n              var prevChar = entry.substr(entry.length - 1);\r\n              if (m0 === delimiter && prevChar === delimiter) {\r\n                entry += m0;\r\n                state = 1;\r\n                break;\r\n              }\r\n              // end of value\r\n              if (m0 === separator) {\r\n                entry += m0;\r\n                state = 0;\r\n                break;\r\n              }\r\n              // end of line\r\n              if (m0 === '\\n') {\r\n                endOfLine();\r\n                break;\r\n              }\r\n              // phantom carriage return\r\n              if (m0 === '\\r') {\r\n                break;\r\n              }\r\n              // broken paser?\r\n              throw Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\r\n\r\n            // un-delimited input\r\n            case 3:\r\n              // null value\r\n              if (m0 === separator) {\r\n                entry += m0;\r\n                state = 0;\r\n                break;\r\n              }\r\n              // end of line\r\n              if (m0 === '\\n') {\r\n                endOfLine();\r\n                break;\r\n              }\r\n              // phantom carriage return\r\n              if (m0 === '\\r') {\r\n                break;\r\n              }\r\n              // non-compliant data\r\n              if (m0 === delimiter) {\r\n                throw Error('CSVDataError: Illegal quote [Row:' + options.state.rowNum + ']');\r\n              }\r\n              // broken parser?\r\n              throw Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\r\n            default:\r\n              // shenanigans\r\n              throw Error('CSVDataError: Unknown state [Row:' + options.state.rowNum + ']');\r\n          }\r\n          // console.log('val:' + m0 + ' state:' + state);\r\n        });\r\n\r\n        // submit the last entry\r\n        // ignore null last line\r\n        if (entry !== '') {\r\n          endOfLine();\r\n        }\r\n\r\n        return entries;\r\n      },\r\n\r\n      // a csv entry parser\r\n      parseEntry: function (csv, options) {\r\n        // cache settings\r\n        var separator = options.separator;\r\n        var delimiter = options.delimiter;\r\n\r\n        // set initial state if it's missing\r\n        if (!options.state.rowNum) {\r\n          options.state.rowNum = 1;\r\n        }\r\n        if (!options.state.colNum) {\r\n          options.state.colNum = 1;\r\n        }\r\n\r\n        // clear initial state\r\n        var entry = [];\r\n        var state = 0;\r\n        var value = '';\r\n\r\n        function endOfValue () {\r\n          if (options.onParseValue === undefined) {\r\n            // onParseValue hook not set\r\n            entry.push(value);\r\n          } else {\r\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\r\n            // false skips the value, configurable through a hook\r\n            if (hook !== false) {\r\n              entry.push(hook);\r\n            }\r\n          }\r\n          // reset the state\r\n          value = '';\r\n          state = 0;\r\n          // update global state\r\n          options.state.colNum++;\r\n        }\r\n\r\n        // checked for a cached regEx first\r\n        if (!options.match) {\r\n          // escape regex-specific control chars\r\n          var escSeparator = RegExp.escape(separator);\r\n          var escDelimiter = RegExp.escape(delimiter);\r\n\r\n          // compile the regEx str using the custom delimiter/separator\r\n          var match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/;\r\n          var matchSrc = match.source;\r\n          matchSrc = matchSrc.replace(/S/g, escSeparator);\r\n          matchSrc = matchSrc.replace(/D/g, escDelimiter);\r\n          options.match = new RegExp(matchSrc, 'gm');\r\n        }\r\n\r\n        // put on your fancy pants...\r\n        // process control chars individually, use look-ahead on non-control chars\r\n        csv.replace(options.match, function (m0) {\r\n          switch (state) {\r\n            // the start of a value\r\n            case 0:\r\n              // null last value\r\n              if (m0 === separator) {\r\n                value += '';\r\n                endOfValue();\r\n                break;\r\n              }\r\n              // opening delimiter\r\n              if (m0 === delimiter) {\r\n                state = 1;\r\n                break;\r\n              }\r\n              // skip un-delimited new-lines\r\n              if (m0 === '\\n' || m0 === '\\r') {\r\n                break;\r\n              }\r\n              // un-delimited value\r\n              value += m0;\r\n              state = 3;\r\n              break;\r\n\r\n            // delimited input\r\n            case 1:\r\n              // second delimiter? check further\r\n              if (m0 === delimiter) {\r\n                state = 2;\r\n                break;\r\n              }\r\n              // delimited data\r\n              value += m0;\r\n              state = 1;\r\n              break;\r\n\r\n            // delimiter found in delimited input\r\n            case 2:\r\n              // escaped delimiter?\r\n              if (m0 === delimiter) {\r\n                value += m0;\r\n                state = 1;\r\n                break;\r\n              }\r\n              // null value\r\n              if (m0 === separator) {\r\n                endOfValue();\r\n                break;\r\n              }\r\n              // skip un-delimited new-lines\r\n              if (m0 === '\\n' || m0 === '\\r') {\r\n                break;\r\n              }\r\n              // broken paser?\r\n              throw Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\r\n\r\n            // un-delimited input\r\n            case 3:\r\n              // null last value\r\n              if (m0 === separator) {\r\n                endOfValue();\r\n                break;\r\n              }\r\n              // skip un-delimited new-lines\r\n              if (m0 === '\\n' || m0 === '\\r') {\r\n                break;\r\n              }\r\n              // non-compliant data\r\n              if (m0 === delimiter) {\r\n                throw Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\r\n              }\r\n              // broken parser?\r\n              throw Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\r\n            default:\r\n              // shenanigans\r\n              throw Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\r\n          }\r\n          // console.log('val:' + m0 + ' state:' + state);\r\n        });\r\n\r\n        // submit the last value\r\n        endOfValue();\r\n\r\n        return entry;\r\n      }\r\n    },\r\n\r\n    helpers: {\r\n\r\n      /**\r\n       * $.csv.helpers.collectPropertyNames(objectsArray)\r\n       * Collects all unique property names from all passed objects.\r\n       *\r\n       * @param {Array} objects Objects to collect properties from.\r\n       *\r\n       * Returns an array of property names (array will be empty,\r\n       * if objects have no own properties).\r\n       */\r\n      collectPropertyNames: function (objects) {\r\n        var o = [];\r\n        var propName = [];\r\n        var props = [];\r\n        for (o in objects) {\r\n          for (propName in objects[o]) {\r\n            if ((objects[o].hasOwnProperty(propName)) &&\r\n                (props.indexOf(propName) < 0) &&\r\n                (typeof objects[o][propName] !== 'function')) {\r\n              props.push(propName);\r\n            }\r\n          }\r\n        }\r\n        return props;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * $.csv.toArray(csv)\r\n     * Converts a CSV entry string to a javascript array.\r\n     *\r\n     * @param {Array} csv The string containing the CSV data.\r\n     * @param {Object} [options] An object containing user-defined options.\r\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\r\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\r\n     *\r\n     * This method deals with simple CSV strings only. It's useful if you only\r\n     * need to parse a single entry. If you need to parse more than one line,\r\n     * use $.csv2Array instead.\r\n     */\r\n    toArray: function (csv, options, callback) {\r\n      // if callback was passed to options swap callback with options\r\n      if (options !== undefined && typeof (options) === 'function') {\r\n        if (callback !== undefined) {\r\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\r\n        }\r\n        callback = options;\r\n        options = {};\r\n      }\r\n\r\n      options = (options !== undefined ? options : {});\r\n      var config = {};\r\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false);\r\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\r\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\r\n      var state = (options.state !== undefined ? options.state : {});\r\n\r\n      // setup\r\n      options = {\r\n        delimiter: config.delimiter,\r\n        separator: config.separator,\r\n        onParseEntry: options.onParseEntry,\r\n        onParseValue: options.onParseValue,\r\n        state: state\r\n      };\r\n\r\n      var entry = $.csv.parsers.parseEntry(csv, options);\r\n\r\n      // push the value to a callback if one is defined\r\n      if (!config.callback) {\r\n        return entry;\r\n      } else {\r\n        config.callback('', entry);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * $.csv.toArrays(csv)\r\n     * Converts a CSV string to a javascript array.\r\n     *\r\n     * @param {String} csv The string containing the raw CSV data.\r\n     * @param {Object} [options] An object containing user-defined options.\r\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\r\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\r\n     *\r\n     * This method deals with multi-line CSV. The breakdown is simple. The first\r\n     * dimension of the array represents the line (or entry/row) while the second\r\n     * dimension contains the values (or values/columns).\r\n     */\r\n    toArrays: function (csv, options, callback) {\r\n      // if callback was passed to options swap callback with options\r\n      if (options !== undefined && typeof (options) === 'function') {\r\n        if (callback !== undefined) {\r\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\r\n        }\r\n        callback = options;\r\n        options = {};\r\n      }\r\n\r\n      options = (options !== undefined ? options : {});\r\n      var config = {};\r\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false);\r\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\r\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\r\n\r\n      // setup\r\n      var data = [];\r\n      options = {\r\n        delimiter: config.delimiter,\r\n        separator: config.separator,\r\n        onPreParse: options.onPreParse,\r\n        onParseEntry: options.onParseEntry,\r\n        onParseValue: options.onParseValue,\r\n        onPostParse: options.onPostParse,\r\n        start: options.start,\r\n        end: options.end,\r\n        state: {\r\n          rowNum: 1,\r\n          colNum: 1\r\n        }\r\n      };\r\n\r\n      // onPreParse hook\r\n      if (options.onPreParse !== undefined) {\r\n        csv = options.onPreParse(csv, options.state);\r\n      }\r\n\r\n      // parse the data\r\n      data = $.csv.parsers.parse(csv, options);\r\n\r\n      // onPostParse hook\r\n      if (options.onPostParse !== undefined) {\r\n        data = options.onPostParse(data, options.state);\r\n      }\r\n\r\n      // push the value to a callback if one is defined\r\n      if (!config.callback) {\r\n        return data;\r\n      } else {\r\n        config.callback('', data);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * $.csv.toObjects(csv)\r\n     * Converts a CSV string to a javascript object.\r\n     * @param {String} csv The string containing the raw CSV data.\r\n     * @param {Object} [options] An object containing user-defined options.\r\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\r\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\r\n     * @param {Boolean} [headers] Indicates whether the data contains a header line. Defaults to true.\r\n     *\r\n     * This method deals with multi-line CSV strings. Where the headers line is\r\n     * used as the key for each value per entry.\r\n     */\r\n    toObjects: function (csv, options, callback) {\r\n      // if callback was passed to options swap callback with options\r\n      if (options !== undefined && typeof (options) === 'function') {\r\n        if (callback !== undefined) {\r\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\r\n        }\r\n        callback = options;\r\n        options = {};\r\n      }\r\n\r\n      options = (options !== undefined ? options : {});\r\n      var config = {};\r\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false);\r\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\r\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\r\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;\r\n      options.start = 'start' in options ? options.start : 1;\r\n\r\n      // account for headers\r\n      if (config.headers) {\r\n        options.start++;\r\n      }\r\n      if (options.end && config.headers) {\r\n        options.end++;\r\n      }\r\n\r\n      // setup\r\n      var lines = [];\r\n      var data = [];\r\n\r\n      options = {\r\n        delimiter: config.delimiter,\r\n        separator: config.separator,\r\n        onPreParse: options.onPreParse,\r\n        onParseEntry: options.onParseEntry,\r\n        onParseValue: options.onParseValue,\r\n        onPostParse: options.onPostParse,\r\n        start: options.start,\r\n        end: options.end,\r\n        state: {\r\n          rowNum: 1,\r\n          colNum: 1\r\n        },\r\n        match: false,\r\n        transform: options.transform\r\n      };\r\n\r\n      // fetch the headers\r\n      var headerOptions = {\r\n        delimiter: config.delimiter,\r\n        separator: config.separator,\r\n        start: 1,\r\n        end: 1,\r\n        state: {\r\n          rowNum: 1,\r\n          colNum: 1\r\n        },\r\n        headers: true\r\n      };\r\n\r\n      // onPreParse hook\r\n      if (options.onPreParse !== undefined) {\r\n        csv = options.onPreParse(csv, options.state);\r\n      }\r\n\r\n      // parse the csv\r\n      var headerLine = $.csv.parsers.splitLines(csv, headerOptions);\r\n      var headers = $.csv.toArray(headerLine[0], headerOptions);\r\n\r\n      // fetch the data\r\n      lines = $.csv.parsers.splitLines(csv, options);\r\n\r\n      // reset the state for re-use\r\n      options.state.colNum = 1;\r\n      if (headers) {\r\n        options.state.rowNum = 2;\r\n      } else {\r\n        options.state.rowNum = 1;\r\n      }\r\n\r\n      // convert data to objects\r\n      for (var i = 0, len = lines.length; i < len; i++) {\r\n        var entry = $.csv.toArray(lines[i], options);\r\n        var object = {};\r\n        for (var j = 0; j < headers.length; j++) {\r\n          object[headers[j]] = entry[j];\r\n        }\r\n        if (options.transform !== undefined) {\r\n          data.push(options.transform.call(undefined, object));\r\n        } else {\r\n          data.push(object);\r\n        }\r\n\r\n        // update row state\r\n        options.state.rowNum++;\r\n      }\r\n\r\n      // onPostParse hook\r\n      if (options.onPostParse !== undefined) {\r\n        data = options.onPostParse(data, options.state);\r\n      }\r\n\r\n      // push the value to a callback if one is defined\r\n      if (!config.callback) {\r\n        return data;\r\n      } else {\r\n        config.callback('', data);\r\n      }\r\n    },\r\n\r\n    /**\r\n    * $.csv.fromArrays(arrays)\r\n    * Converts a javascript array to a CSV String.\r\n    *\r\n    * @param {Array} arrays An array containing an array of CSV entries.\r\n    * @param {Object} [options] An object containing user-defined options.\r\n    * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\r\n    * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\r\n    *\r\n    * This method generates a CSV file from an array of arrays (representing entries).\r\n    */\r\n    fromArrays: function (arrays, options, callback) {\r\n      // if callback was passed to options swap callback with options\r\n      if (options !== undefined && typeof (options) === 'function') {\r\n        if (callback !== undefined) {\r\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\r\n        }\r\n        callback = options;\r\n        options = {};\r\n      }\r\n\r\n      options = (options !== undefined ? options : {});\r\n      var config = {};\r\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false);\r\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\r\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\r\n\r\n      var output = '';\r\n      var line;\r\n      var lineValues;\r\n      var i;\r\n      var j;\r\n\r\n      for (i = 0; i < arrays.length; i++) {\r\n        line = arrays[i];\r\n        lineValues = [];\r\n        for (j = 0; j < line.length; j++) {\r\n          var strValue = (line[j] === undefined || line[j] === null) ? '' : line[j].toString();\r\n          if (strValue.indexOf(config.delimiter) > -1) {\r\n            strValue = strValue.replace(new RegExp(config.delimiter, 'g'), config.delimiter + config.delimiter);\r\n          }\r\n\r\n          var escMatcher = '\\n|\\r|S|D';\r\n          escMatcher = escMatcher.replace('S', config.separator);\r\n          escMatcher = escMatcher.replace('D', config.delimiter);\r\n\r\n          if (strValue.search(escMatcher) > -1) {\r\n            strValue = config.delimiter + strValue + config.delimiter;\r\n          }\r\n          lineValues.push(strValue);\r\n        }\r\n        output += lineValues.join(config.separator) + '\\n';\r\n      }\r\n\r\n      // push the value to a callback if one is defined\r\n      if (!config.callback) {\r\n        return output;\r\n      } else {\r\n        config.callback('', output);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * $.csv.fromObjects(objects)\r\n     * Converts a javascript dictionary to a CSV string.\r\n     *\r\n     * @param {Object} objects An array of objects containing the data.\r\n     * @param {Object} [options] An object containing user-defined options.\r\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\r\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\r\n     * @param {Character} [sortOrder] Sort order of columns (named after\r\n     *   object properties). Use 'alpha' for alphabetic. Default is 'declare',\r\n     *   which means, that properties will _probably_ appear in order they were\r\n     *   declared for the object. But without any guarantee.\r\n     * @param {Character or Array} [manualOrder] Manually order columns. May be\r\n     * a strin in a same csv format as an output or an array of header names\r\n     * (array items won't be parsed). All the properties, not present in\r\n     * `manualOrder` will be appended to the end in accordance with `sortOrder`\r\n     * option. So the `manualOrder` always takes preference, if present.\r\n     *\r\n     * This method generates a CSV file from an array of objects (name:value pairs).\r\n     * It starts by detecting the headers and adding them as the first line of\r\n     * the CSV file, followed by a structured dump of the data.\r\n     */\r\n    fromObjects: function (objects, options, callback) {\r\n      // if callback was passed to options swap callback with options\r\n      if (options !== undefined && typeof (options) === 'function') {\r\n        if (callback !== undefined) {\r\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\r\n        }\r\n        callback = options;\r\n        options = {};\r\n      }\r\n\r\n      options = (options !== undefined ? options : {});\r\n      var config = {};\r\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false);\r\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\r\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\r\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;\r\n      config.sortOrder = 'sortOrder' in options ? options.sortOrder : 'declare';\r\n      config.manualOrder = 'manualOrder' in options ? options.manualOrder : [];\r\n      config.transform = options.transform;\r\n\r\n      if (typeof config.manualOrder === 'string') {\r\n        config.manualOrder = $.csv.toArray(config.manualOrder, config);\r\n      }\r\n\r\n      if (config.transform !== undefined) {\r\n        var origObjects = objects;\r\n        objects = [];\r\n\r\n        var i;\r\n        for (i = 0; i < origObjects.length; i++) {\r\n          objects.push(config.transform.call(undefined, origObjects[i]));\r\n        }\r\n      }\r\n\r\n      var props = $.csv.helpers.collectPropertyNames(objects);\r\n\r\n      if (config.sortOrder === 'alpha') {\r\n        props.sort();\r\n      } // else {} - nothing to do for 'declare' order\r\n\r\n      if (config.manualOrder.length > 0) {\r\n        var propsManual = [].concat(config.manualOrder);\r\n        var p;\r\n        for (p = 0; p < props.length; p++) {\r\n          if (propsManual.indexOf(props[p]) < 0) {\r\n            propsManual.push(props[p]);\r\n          }\r\n        }\r\n        props = propsManual;\r\n      }\r\n\r\n      var o;\r\n      var line;\r\n      var output = [];\r\n      var propName;\r\n      if (config.headers) {\r\n        output.push(props);\r\n      }\r\n\r\n      for (o = 0; o < objects.length; o++) {\r\n        line = [];\r\n        for (p = 0; p < props.length; p++) {\r\n          propName = props[p];\r\n          if (propName in objects[o] && typeof objects[o][propName] !== 'function') {\r\n            line.push(objects[o][propName]);\r\n          } else {\r\n            line.push('');\r\n          }\r\n        }\r\n        output.push(line);\r\n      }\r\n\r\n      // push the value to a callback if one is defined\r\n      return $.csv.fromArrays(output, options, config.callback);\r\n    }\r\n  };\r\n\r\n  // Maintenance code to maintain backward-compatibility\r\n  // Will be removed in release 1.0\r\n  $.csvEntry2Array = $.csv.toArray;\r\n  $.csv2Array = $.csv.toArrays;\r\n  $.csv2Dictionary = $.csv.toObjects;\r\n\r\n  // CommonJS module is defined\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = $.csv;\r\n  }\r\n}).call(this);\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- js/jquery.csv.js	(revision 55b3f74f53e4a7410686d955819779b9a99cd97c)
+++ js/jquery.csv.js	(date 1602988079104)
@@ -683,6 +683,7 @@
      * dimension of the array represents the line (or entry/row) while the second
      * dimension contains the values (or values/columns).
      */
+
     toArrays: function (csv, options, callback) {
       // if callback was passed to options swap callback with options
       if (options !== undefined && typeof (options) === 'function') {
